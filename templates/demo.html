<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AstroVenture Exoplanet Classifier</title>
  <!-- Tailwind via CDN for quick styling -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- TensorFlow.js -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
  <!-- PapaParse for CSV parsing -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <!-- Chart.js for charts -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <style>
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  </style>
</head>
<body class="bg-slate-950 text-slate-100 min-h-screen">
  <header class="px-6 py-5 border-b border-slate-800 bg-slate-900/60 backdrop-blur">
    <h1 class="text-2xl sm:text-3xl font-bold">ðŸš€ AstroVenture Exoplanet Classifier</h1>
    <p class="text-slate-300 mt-1">Train a tiny AI in your browser to identify exoplanets from NASA-style tabular data.</p>
  </header>

  <main class="max-w-6xl mx-auto p-6 grid gap-6">
    <section class="grid lg:grid-cols-3 gap-6">
      <div class="lg:col-span-2 bg-slate-900/40 rounded-2xl p-5 border border-slate-800 shadow">
        <h2 class="font-semibold text-xl mb-3">1) Load your CSV</h2>
        <p class="text-slate-300 mb-3">CSV must include these columns (header row, case-sensitive by default): <span class="mono">pl_orbper</span>, <span class="mono">pl_rade</span>, <span class="mono">st_mass</span>, <span class="mono">st_teff</span>, and target <span class="mono">is_exoplanet</span> (1 or 0).
          You can also map columns below if your names differ.</p>
        <input id="csvFile" type="file" accept=".csv" class="block w-full text-slate-200 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-600 file:text-white hover:file:bg-indigo-500" />

        <div class="mt-4 grid sm:grid-cols-2 lg:grid-cols-4 gap-4">
          <div>
            <label class="block text-sm text-slate-300">Orbital Period column</label>
            <input id="col_orbper" class="mt-1 w-full bg-slate-900 border border-slate-700 rounded-lg p-2 mono" placeholder="pl_orbper" />
          </div>
          <div>
            <label class="block text-sm text-slate-300">Planet Radius column</label>
            <input id="col_rade" class="mt-1 w-full bg-slate-900 border border-slate-700 rounded-lg p-2 mono" placeholder="pl_rade" />
          </div>
          <div>
            <label class="block text-sm text-slate-300">Stellar Mass column</label>
            <input id="col_stmass" class="mt-1 w-full bg-slate-900 border border-slate-700 rounded-lg p-2 mono" placeholder="st_mass" />
          </div>
          <div>
            <label class="block text-sm text-slate-300">Stellar Teff column</label>
            <input id="col_stteff" class="mt-1 w-full bg-slate-900 border border-slate-700 rounded-lg p-2 mono" placeholder="st_teff" />
          </div>
          <div>
            <label class="block text-sm text-slate-300">Target column</label>
            <input id="col_target" class="mt-1 w-full bg-slate-900 border border-slate-700 rounded-lg p-2 mono" placeholder="is_exoplanet" />
          </div>
        </div>

        <div class="mt-5 flex items-center gap-3">
          <button id="btnPreview" class="px-4 py-2 rounded-xl bg-slate-800 border border-slate-700 hover:bg-slate-700">Preview rows</button>
          <button id="btnTrain" class="px-4 py-2 rounded-xl bg-indigo-600 hover:bg-indigo-500">Train model</button>
          <button id="btnDemo" class="px-4 py-2 rounded-xl bg-emerald-600 hover:bg-emerald-500">Load tiny demo data</button>
        </div>
        <div id="preview" class="mt-4 overflow-auto text-sm mono"></div>
      </div>

      <aside class="bg-slate-900/40 rounded-2xl p-5 border border-slate-800 shadow">
        <h2 class="font-semibold text-xl mb-3">Info & Tips</h2>
        <ul class="list-disc ml-5 space-y-2 text-slate-300">
          <li>Missing values are dropped for selected columns.</li>
          <li>Features are standardized (z-score).</li>
          <li>Train/test split: 80/20, batch size 32, epochs 60.</li>
          <li>Model: 2-layer dense net (ReLU) â†’ sigmoid output.</li>
          <li>Metric: Accuracy, plus precision/recall/F1.</li>
          <li>Feature importance uses permutation on test set.</li>
        </ul>
      </aside>
    </section>

    <section class="grid lg:grid-cols-3 gap-6">
      <div class="bg-slate-900/40 rounded-2xl p-5 border border-slate-800 shadow lg:col-span-2">
        <h2 class="font-semibold text-xl mb-3">Training Log</h2>
        <pre id="log" class="bg-black/40 rounded-xl p-3 text-sm mono h-64 overflow-auto"></pre>
      </div>
      <div class="bg-slate-900/40 rounded-2xl p-5 border border-slate-800 shadow">
        <h2 class="font-semibold text-xl mb-3">Metrics</h2>
        <div id="metrics" class="text-sm space-y-1"></div>
      </div>
    </section>

    <section class="grid lg:grid-cols-2 gap-6">
      <div class="bg-slate-900/40 rounded-2xl p-5 border border-slate-800 shadow">
        <h2 class="font-semibold text-xl mb-3">Confusion Matrix</h2>
        <canvas id="cmChart" height="200"></canvas>
      </div>
      <div class="bg-slate-900/40 rounded-2xl p-5 border border-slate-800 shadow">
        <h2 class="font-semibold text-xl mb-3">Permutation Feature Importance</h2>
        <canvas id="fiChart" height="200"></canvas>
      </div>
    </section>
  </main>

  <script>
    const logEl = document.getElementById('log');
    const metricsEl = document.getElementById('metrics');
    const previewEl = document.getElementById('preview');

    const buttons = {
      preview: document.getElementById('btnPreview'),
      train: document.getElementById('btnTrain'),
      demo: document.getElementById('btnDemo'),
    };

    const inputs = {
      file: document.getElementById('csvFile'),
      orb: document.getElementById('col_orbper'),
      rade: document.getElementById('col_rade'),
      stmass: document.getElementById('col_stmass'),
      stteff: document.getElementById('col_stteff'),
      target: document.getElementById('col_target'),
    };

    function log(msg) {
      logEl.textContent += msg + "\n";
      logEl.scrollTop = logEl.scrollHeight;
    }

    let rawRows = [];

    function getColNames() {
      return {
        orb: inputs.orb.value.trim() || 'pl_orbper',
        rade: inputs.rade.value.trim() || 'pl_rade',
        stmass: inputs.stmass.value.trim() || 'st_mass',
        stteff: inputs.stteff.value.trim() || 'st_teff',
        target: inputs.target.value.trim() || 'is_exoplanet',
      };
    }

    function previewRows(rows, n=10) {
      if (!rows || !rows.length) { previewEl.textContent = 'No rows parsed yet.'; return; }
      const head = Object.keys(rows[0]);
      const table = document.createElement('table');
      table.className = 'w-full text-xs border-collapse';
      table.innerHTML = <thead><tr>${head.map(h=><th class='text-left border-b border-slate-700 py-1 pr-3'>${h}</th>).join('')}</tr></thead>;
      const tb = document.createElement('tbody');
      rows.slice(0,n).forEach(r=>{
        const tr = document.createElement('tr');
        tr.innerHTML = head.map(h=><td class='border-b border-slate-800 py-1 pr-3'>${r[h]}</td>).join('');
        tb.appendChild(tr);
      });
      table.appendChild(tb);
      previewEl.innerHTML = '';
      previewEl.appendChild(table);
    }

    async function parseFile(file) {
      return new Promise((resolve, reject) => {
        Papa.parse(file, {
          header: true,
          dynamicTyping: true,
          skipEmptyLines: true,
          complete: (res) => resolve(res.data),
          error: reject
        });
      });
    }

    function zscore(arr) {
      const mean = arr.reduce((a,b)=>a+b,0)/arr.length;
      const std = Math.sqrt(arr.reduce((s,x)=>s+(x-mean)**2,0)/arr.length) || 1;
      return arr.map(x=> (x-mean)/std);
    }

    function trainTestSplit(data, testRatio=0.2) {
      const idx = data.map((_,i)=>i);
      for (let i=idx.length-1;i>0;i--) { const j=Math.floor(Math.random()*(i+1)); [idx[i],idx[j]]=[idx[j],idx[i]]; }
      const testSize = Math.floor(data.length*testRatio);
      const testIdx = new Set(idx.slice(0,testSize));
      const train = [], test = [];
      data.forEach((row,i)=> (testIdx.has(i)? test:train).push(row));
      return {train, test};
    }

    function toTensors(rows, featCols, targetCol) {
      const feats = featCols.map(c=> rows.map(r=> Number(r[c])));
      const scaled = feats.map(col=> zscore(col));
      const xs = tf.tensor2d(rows.map((_,i)=> scaled.map(col=> col[i])));
      const ys = tf.tensor2d(rows.map(r=> [Number(r[targetCol])||0]));
      return {xs, ys};
    }

    function validRow(r, cols) {
      return cols.every(c => r[c] !== undefined && r[c] !== null && r[c] !== '' && !Number.isNaN(Number(r[c])));
    }

    async function buildAndTrain(xsTrain, ysTrain, xsVal, ysVal) {
      const model = tf.sequential();
      model.add(tf.layers.dense({units: 16, activation: 'relu', inputShape: [xsTrain.shape[1]]}));
      model.add(tf.layers.dense({units: 8, activation: 'relu'}));
      model.add(tf.layers.dense({units: 1, activation: 'sigmoid'}));
      model.compile({optimizer: tf.train.adam(0.01), loss: 'binaryCrossentropy', metrics: ['accuracy']});

      log('Training started...');
      const h = await model.fit(xsTrain, ysTrain, {
        epochs: 60,
        batchSize: 32,
        validationData: [xsVal, ysVal],
        callbacks: {
          onEpochEnd: (epoch, logs) => log(`Epoch ${epoch+1}/60 â€” loss: ${logs.loss.toFixed(4)}, acc: ${logs.acc?.toFixed(4)}, val_acc: ${logs.val_acc?.toFixed(4)}`)
        }
      });
      log('Training finished.');
      return model;
    }

    function computeMetrics(yTrue, yProb, thr=0.5) {
      const yPred = yProb.map(p=> p>=thr?1:0);
      const tp = yTrue.filter((y,i)=> y===1 && yPred[i]===1).length;
      const tn = yTrue.filter((y,i)=> y===0 && yPred[i]===0).length;
      const fp = yTrue.filter((y,i)=> y===0 && yPred[i]===1).length;
      const fn = yTrue.filter((y,i)=> y===1 && yPred[i]===0).length;
      const acc = (tp+tn)/(tp+tn+fp+fn);
      const prec = tp/(tp+fp || 1);
      const rec = tp/(tp+fn || 1);
      const f1 = 2*prec*rec/(prec+rec || 1);
      return {acc, prec, rec, f1, cm: [[tn, fp],[fn, tp]]};
    }

    function renderMetrics(m) {
      metricsEl.innerHTML = `
        <div>Accuracy: <span class="font-semibold">${(m.acc*100).toFixed(2)}%</span></div>
        <div>Precision: <span class="font-semibold">${(m.prec*100).toFixed(2)}%</span></div>
        <div>Recall: <span class="font-semibold">${(m.rec*100).toFixed(2)}%</span></div>
        <div>F1 Score: <span class="font-semibold">${(m.f1*100).toFixed(2)}%</span></div>
      `;
    }

    let cmChart, fiChart;
    function renderCM(cm) {
      const ctx = document.getElementById('cmChart');
      cmChart?.destroy();
      cmChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: ['TN','FP','FN','TP'],
          datasets: [{ label: 'Counts', data: [cm[0][0], cm[0][1], cm[1][0], cm[1][1]] }]
        },
        options: { responsive: true, plugins: { legend: { display: false } } }
      });
    }

    async function permutationFI(model, xs, ys, featNames) {
      // xs is tensor2d; we'll copy to array for shuffling
      const baseProb = await model.predict(xs).data();
      const yTrue = (await ys.data()).map(v=> Number(v));
      const base = computeMetrics(yTrue, Array.from(baseProb));
      const arr = await xs.array();
      const scores = [];
      for (let f=0; f<featNames.length; f++) {
        const shuf = arr.map(row=> row.slice());
        // shuffle column f
        for (let i=shuf.length-1;i>0;i--) { const j=Math.floor(Math.random()*(i+1)); [shuf[i][f], shuf[j][f]]=[shuf[j][f], shuf[i][f]]; }
        const xsShuf = tf.tensor2d(shuf);
        const prob = await model.predict(xsShuf).data();
        const met = computeMetrics(yTrue, Array.from(prob));
        const drop = base.acc - met.acc; // accuracy drop
        scores.push(drop);
        xsShuf.dispose();
      }
      return {baseAcc: base.acc, scores};
    }

    function renderFI(names, scores) {
      const ctx = document.getElementById('fiChart');
      fiChart?.destroy();
      fiChart = new Chart(ctx, {
        type: 'bar',
        data: { labels: names, datasets: [{ label: 'Accuracy drop when shuffled (â†‘ = more important)', data: scores }] },
        options: { responsive: true }
      });
    }

    // Event handlers
    inputs.file.addEventListener('change', async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      rawRows = await parseFile(file);
      log(`Parsed ${rawRows.length} rows.`);
      previewRows(rawRows);
    });

    buttons.preview.addEventListener('click', () => previewRows(rawRows));

    buttons.demo.addEventListener('click', () => {
      // Tiny synthetic-like demo dataset (do not reflect real distributions)
      const demo = [];
      function push(orb, rade, smass, steff, y){ demo.push({pl_orbper:orb, pl_rade:rade, st_mass:smass, st_teff:steff, is_exoplanet:y}); }
      for (let i=0;i<120;i++) push(5+Math.random()*20, 1+Math.random()*1.5, 0.7+Math.random()*0.6, 4500+Math.random()*1500, 1);
      for (let i=0;i<120;i++) push(50+Math.random()*200, 3+Math.random()*5, 0.5+Math.random()*1.5, 3000+Math.random()*4000, 0);
      rawRows = demo;
      previewRows(rawRows);
      log('Loaded tiny demo data (synthetic).');
    });

    buttons.train.addEventListener('click', async () => {
      if (!rawRows.length) { alert('Please load a CSV or the demo data first.'); return; }
      const cols = getColNames();
      const featCols = [cols.orb, cols.rade, cols.stmass, cols.stteff];
      const targetCol = cols.target;

      const filtered = rawRows.filter(r=> validRow(r, [...featCols, targetCol]));
      if (filtered.length < 40) { alert('Not enough valid rows after cleaning (need > 40).'); return; }

      const {train, test} = trainTestSplit(filtered, 0.2);
      const {xs: xsTrain, ys: ysTrain} = toTensors(train, featCols, targetCol);
      const {xs: xsTest, ys: ysTest} = toTensors(test, featCols, targetCol);

      xsTrain.print ? null : null; // keep linter calm

      const model = await buildAndTrain(xsTrain, ysTrain, xsTest, ysTest);

      const prob = await model.predict(xsTest).data();
      const yTrue = (await ysTest.data()).map(v=> Number(v));
      const m = computeMetrics(yTrue, Array.from(prob));
      renderMetrics(m);
      renderCM(m.cm);

      const fi = await permutationFI(model, xsTest, ysTest, featCols);
      renderFI(['orbper','rade','st_mass','st_teff'], fi.scores.map(s=> Number(s.toFixed(4))));

      xsTrain.dispose(); ysTrain.dispose(); xsTest.dispose(); ysTest.dispose();
      log('All done âœ…');
    });
  </script>
</body>
</html>